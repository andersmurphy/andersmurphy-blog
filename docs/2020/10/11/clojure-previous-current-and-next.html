<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: previous, current and next</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="https://andersmurphy.com/styles.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="https://andersmurphy.com/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="https://andersmurphy.com/assets/anderspixel.png" width="60" /><h1><a href="https://andersmurphy.com/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="https://andersmurphy.com/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Clojure: previous, current and next</h1><time class="post-date" datetime="2020-10-11T00:00:00+00:00">11 Oct 2020</time><p>This article will cover a common pattern of iterating over a list of items whilst keeping a reference to the previous, current and next item.</p><p>Recently I had to implement link pagination for this blog. My initial attempt was rather naive:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>link-pages</strong>
  &#91;pages&#93;
  <span class="dim">&#40;</span>reduce
   <span class="dim">&#40;</span>fn &#91;pages next-page&#93;
     <span class="dim">&#40;</span>let &#91;previous-page <span class="dim">&#40;</span>first pages<span class="dim">&#41;</span>&#93;
       <span class="dim">&#40;</span>if previous-page
         <span class="dim">&#40;</span>conj
          <span class="dim">&#40;</span>drop 1 pages<span class="dim">&#41;</span>
          <span class="dim">&#40;</span>assoc previous-page :next-page <span class="dim">&#40;</span>:name next-page<span class="dim">&#41;&#41;</span>
          <span class="dim">&#40;</span>assoc next-page :previous-page <span class="dim">&#40;</span>:name previous-page<span class="dim">&#41;&#41;&#41;</span>
         <span class="dim">&#40;</span>conj pages next-page<span class="dim">&#41;&#41;&#41;&#41;</span>
   '<span class="dim">&#40;</span><span class="dim">&#41;</span>
   pages<span class="dim">&#41;&#41;</span>
</code></pre><p>Using <code>conj</code> and an empty list to build a new list of pages that reference each other. It also had an inconvenient side effect of reversing the input list.</p><pre><code class="clojure"><span class="dim">&#40;</span>link-pages
  &#91;{:name &quot;page1&quot;}
   {:name &quot;page2&quot;}
   {:name &quot;page3&quot;}
   {:name &quot;page4&quot;}
   {:name &quot;page5&quot;}&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
<span class="dim">&#40;</span>{:name &quot;page5&quot;, :previous-page &quot;page4&quot;}
 {:name &quot;page4&quot;, :previous-page &quot;page3&quot;, :next-page &quot;page5&quot;}
 {:name &quot;page3&quot;, :previous-page &quot;page2&quot;, :next-page &quot;page4&quot;}
 {:name &quot;page2&quot;, :previous-page &quot;page1&quot;, :next-page &quot;page3&quot;}
 {:name &quot;page1&quot;, :next-page &quot;page2&quot;}<span class="dim">&#41;</span>
</code></pre><p>I've since found a much more elegant way of implementing this:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>link-pages</strong>
  &#91;pages&#93;
  <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>concat &#91;nil&#93; pages &#91;nil&#93;<span class="dim">&#41;</span>
       <span class="dim">&#40;</span>partition 3 1<span class="dim">&#41;</span>
       <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;&#91;prev current next&#93;&#93;
              <span class="dim">&#40;</span>cond-&gt; current
                prev <span class="dim">&#40;</span>assoc :previous-page <span class="dim">&#40;</span>:name prev<span class="dim">&#41;&#41;</span>
                next <span class="dim">&#40;</span>assoc :next-page     <span class="dim">&#40;</span>:name next<span class="dim">&#41;&#41;&#41;&#41;&#41;&#41;&#41;</span>
</code></pre><p>The core of this implementation revolves around the <code>partition</code> function which partitions a list into chunks (smaller lists) of n items (in this case 3). It can also be supplied an step which is the number of items to offset each chunk by. For example:</p><pre><code class="clojure"><span class="dim">&#40;</span>partition 3 1 &#91;1 2 3 4 6 7 8 9&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
<span class="dim">;; <span class="dim">&#40;</span>prev current next<span class="dim">&#41;</span>
</span><span class="dim">&#40;&#40;</span>1 2 3<span class="dim">&#41;</span> <span class="dim">&#40;</span>2 3 4<span class="dim">&#41;</span> <span class="dim">&#40;</span>3 4 6<span class="dim">&#41;</span> <span class="dim">&#40;</span>4 6 7<span class="dim">&#41;</span> <span class="dim">&#40;</span>6 7 8<span class="dim">&#41;</span> <span class="dim">&#40;</span>7 8 9<span class="dim">&#41;&#41;</span>
</code></pre><p>We use <code>nil</code> to denote the beginning and end of the list by adding it to the beginning and end of our initial input.</p><pre><code class="clojure"><span class="dim">&#40;</span>partition 3 1 &#91;nil 1 2 3 4 6 7 8 9 nil&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
<span class="dim">;; <span class="dim">&#40;</span>prev current next<span class="dim">&#41;</span>
</span><span class="dim">&#40;&#40;</span>nil 1 2<span class="dim">&#41;</span> <span class="dim">&#40;</span>1 2 3<span class="dim">&#41;</span> <span class="dim">&#40;</span>2 3 4<span class="dim">&#41;</span> <span class="dim">&#40;</span>3 4 6<span class="dim">&#41;</span> <span class="dim">&#40;</span>4 6 7<span class="dim">&#41;</span> <span class="dim">&#40;</span>6 7 8<span class="dim">&#41;</span> <span class="dim">&#40;</span>7 8 9<span class="dim">&#41;</span> <span class="dim">&#40;</span>8 9 nil<span class="dim">&#41;&#41;</span>
</code></pre><p>Finally <code>cond-&gt;</code> is just a nice way to conditionally do some things to a map (note that, unlike <code>cond</code>, <code>cond-&gt;</code> doesn't short circuit after the first true expression).</p><pre><code class="clojur">&#40;link-pages
  &#91;{:name &quot;page1&quot;}
   {:name &quot;page2&quot;}
   {:name &quot;page3&quot;}
   {:name &quot;page4&quot;}
   {:name &quot;page5&quot;}&#93;&#41;

=&gt;
&#40;{:name &quot;page1&quot;, :next-page &quot;page2&quot;}
 {:name &quot;page2&quot;, :previous-page &quot;page1&quot;, :next-page &quot;page3&quot;}
 {:name &quot;page3&quot;, :previous-page &quot;page2&quot;, :next-page &quot;page4&quot;}
 {:name &quot;page4&quot;, :previous-page &quot;page3&quot;, :next-page &quot;page5&quot;}
 {:name &quot;page5&quot;, :previous-page &quot;page4&quot;}&#41;
</code></pre><p>Not only is this solution simpler, it no longer has the side effect of reversing the list.</p><p>The full example of the pagination logic for this blog can be found <a href='https://github.com/andersmurphy/andersmurphy-blog/blob/232e86a9e19098856d2b3fd902408fb1118440ff/src/core.clj#L208'>here</a>.</p></article><div class="footer"><p>Â© 2015-2024 Anders Murphy</p></div></div></body></html>