<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: jdbc using any and all as alternatives to in</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="/styles.css" rel="stylesheet" type="text/css" /><link href="/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="/assets/anderspixel.png" width="60" /><h1><a href="/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Clojure: jdbc using any and all as alternatives to in</h1><time class="post-date" datetime="2020-09-06T00:00:00+00:00">06 Sep 2020</time><p><a href='https://github.com/seancorfield/next-jdbc'>next-jdbc</a> uses parameterised queries to prevent SQL Injections. These queries can take parameters by passing question marks (?) in the query and then by replacing each question mark index with required values. However this can make some sql operators more challenging to use programmatically. In particular <code>in&#40;?,?,?&#41;</code>. In this post we cover using <a href='https://www.postgresql.org/'>postgresql</a>'s <code>any&#40;?&#41;</code> and <code>all&#40;?&#41;</code> to get around this.</p><p>First we need to set up a database:</p><pre><code class="clojure"><span class="dim">&#40;</span>ns <strong>in-any-all.core</strong>
  <span class="dim">&#40;</span>:require &#91;next.jdbc :as jdbc&#93;
            &#91;next.jdbc.sql :as sql&#93;
            &#91;clojure.string :as str&#93;
            &#91;next.jdbc.prepare :as p&#93;<span class="dim">&#41;</span>
  <span class="dim">&#40;</span>:import &#91;java.sql PreparedStatement&#93;<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>def <strong>db</strong> {:dbtype &quot;postgresql&quot; :dbname &quot;databasename&quot;}<span class="dim">&#41;</span>
<span class="dim">&#40;</span>def <strong>ds</strong> <span class="dim">&#40;</span>jdbc/get-datasource db<span class="dim">&#41;&#41;</span>
</code></pre><p>We need a table:</p><pre><code class="clojure"><span class="dim">&#40;</span>jdbc/execute!
  ds
  &#91;&quot;create table user&#95;info <span class="dim">&#40;</span>pid serial primary key, name text not null<span class="dim">&#41;</span>&quot;&#93;<span class="dim">&#41;</span>
<span class="dim">&#40;</span>jdbc/execute! ds &#91;&quot;create unique index user&#95;info&#95;unique ON user&#95;info<span class="dim">&#40;</span>name<span class="dim">&#41;</span>&quot;&#93;<span class="dim">&#41;</span>
</code></pre><p>And some data:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/insert! ds :user&#95;info {:name &quot;Bob&quot;}<span class="dim">&#41;</span>
<span class="dim">&#40;</span>sql/insert! ds :user&#95;info {:name &quot;Jane&quot;}<span class="dim">&#41;</span>
<span class="dim">&#40;</span>sql/insert! ds :user&#95;info {:name &quot;Megan&quot;}<span class="dim">&#41;</span>
<span class="dim">&#40;</span>sql/insert! ds :user&#95;info {:name &quot;Alice&quot;}<span class="dim">&#41;</span>
</code></pre><p>Use <code>in</code> to find users with the name Bob or Jane:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where name in<span class="dim">&#40;</span>?, ?<span class="dim">&#41;</span>&quot; &quot;Bob&quot; &quot;Jane&quot;&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 1, :name &quot;Bob&quot;} #:user&#95;info{:pid 2, :name &quot;Jane&quot;}&#93;

</code></pre><p>Use <code>not in</code> to find users who don't have the name Bob or Jane:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where name not in<span class="dim">&#40;</span>?, ?<span class="dim">&#41;</span>&quot; &quot;Bob&quot; &quot;Jane&quot;&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 3, :name &quot;Megan&quot;} #:user&#95;info{:pid 4, :name &quot;Alice&quot;}&#93;

</code></pre><p>If we want to use parameterised queries with a variable number of names we would need to do something like this:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 <span class="dim">&#40;</span>let &#91;names &#91;&quot;Bob&quot; &quot;Jane&quot;&#93;&#93;
   <span class="dim">&#40;</span>into &#91;<span class="dim">&#40;</span>str &quot;select &#42; from user&#95;info where name in <span class="dim">&#40;</span>&quot;
               <span class="dim">&#40;</span>str/join &quot;, &quot; <span class="dim">&#40;</span>repeat <span class="dim">&#40;</span>count names<span class="dim">&#41;</span> &quot;?&quot;<span class="dim">&#41;&#41;</span>
               &quot;<span class="dim">&#41;</span>&quot;<span class="dim">&#41;</span>&#93;
         names<span class="dim">&#41;&#41;&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 1, :name &quot;Bob&quot;} #:user&#95;info{:pid 2, :name &quot;Jane&quot;}&#93;

</code></pre><p>The above is quite cumbersome. If we rewrite our query to use <code>=</code> and <code>any</code> we can pass an array to the parameterised query instead:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where name = any<span class="dim">&#40;</span>?<span class="dim">&#41;</span>&quot;
             <span class="dim">&#40;</span>into-array String &#91;&quot;Bob&quot; &quot;Jane&quot;&#93;<span class="dim">&#41;</span>&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 1, :name &quot;Bob&quot;} #:user&#95;info{:pid 2, :name &quot;Jane&quot;}&#93;
</code></pre><p>If we want the same behaviour as <code>not in</code> we can use <code>!=</code> and <code>all</code>:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where name != all<span class="dim">&#40;</span>?<span class="dim">&#41;</span>&quot;
 <span class="dim">&#40;</span>into-array String &#91;&quot;Bob&quot; &quot;Jane&quot;&#93;<span class="dim">&#41;</span>&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 3, :name &quot;Megan&quot;} #:user&#95;info{:pid 4, :name &quot;Alice&quot;}&#93;
</code></pre><p>Though this approach isn't without inconveniences as we have to specify the array type and use <code>into-array</code>.</p><p>We can streamline this by extending the <code>next.jdbc.prepare/SettableParameter</code> protocol to automatically convert Clojure vectors to the appropriate typed array:</p><pre><code class="clojure"><span class="dim">&#40;</span>extend-protocol p/SettableParameter
 clojure.lang.IPersistentVector
   <span class="dim">&#40;</span>set-parameter &#91;v &#94;PreparedStatement s i&#93;
     <span class="dim">&#40;</span>let &#91;conn      <span class="dim">&#40;</span>.getConnection s<span class="dim">&#41;</span>
           meta      <span class="dim">&#40;</span>.getParameterMetaData s<span class="dim">&#41;</span>
           type-name <span class="dim">&#40;</span>.getParameterTypeName meta i<span class="dim">&#41;</span>&#93;
       <span class="dim">&#40;</span>if-let &#91;elem-type <span class="dim">&#40;</span>when <span class="dim">&#40;</span>= <span class="dim">&#40;</span>first type-name<span class="dim">&#41;</span> \&#95;<span class="dim">&#41;</span>
                            <span class="dim">&#40;</span>apply str <span class="dim">&#40;</span>rest type-name<span class="dim">&#41;&#41;&#41;</span>&#93;
         <span class="dim">&#40;</span>.setObject s i <span class="dim">&#40;</span>.createArrayOf conn elem-type <span class="dim">&#40;</span>to-array v<span class="dim">&#41;&#41;&#41;</span>
         <span class="dim">&#40;</span>.setObject i s v<span class="dim">&#41;&#41;&#41;&#41;&#41;</span>
</code></pre><p>So now we can pass vectors straight into our parameterised queries:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where name = any<span class="dim">&#40;</span>?<span class="dim">&#41;</span>&quot; &#91;&quot;Bob&quot; &quot;Jane&quot;&#93;&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 1, :name &quot;Bob&quot;} #:user&#95;info{:pid 2, :name &quot;Jane&quot;}&#93;

<span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where name != all<span class="dim">&#40;</span>?<span class="dim">&#41;</span>&quot; &#91;&quot;Bob&quot; &quot;Jane&quot;&#93;&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 3, :name &quot;Megan&quot;} #:user&#95;info{:pid 4, :name &quot;Alice&quot;}&#93;
</code></pre><p>This also supports different homogeneous array types automatically:</p><pre><code class="clojure"><span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where pid != all<span class="dim">&#40;</span>?<span class="dim">&#41;</span>&quot; &#91;1 2&#93;&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 3, :name &quot;Megan&quot;} #:user&#95;info{:pid 4, :name &quot;Alice&quot;}&#93;

<span class="dim">&#40;</span>sql/query
 ds
 &#91;&quot;select &#42; from user&#95;info where pid = any<span class="dim">&#40;</span>?<span class="dim">&#41;</span>&quot; &#91;1 2&#93;&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
&#91;#:user&#95;info{:pid 1, :name &quot;Bob&quot;} #:user&#95;info{:pid 2, :name &quot;Jane&quot;}&#93;
</code></pre><p>The full example <a href='https://github.com/andersmurphy/clj-cookbook/tree/master/sql/in-any-all'>project can be found here</a>.</p></article><div class="footer"><p>© 2015-2024 Anders Murphy</p></div></div></body></html>