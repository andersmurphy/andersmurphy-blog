<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: code as data</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="https://andersmurphy.com/styles.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="https://andersmurphy.com/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="https://andersmurphy.com/assets/anderspixel.png" width="60" /><h1><a href="https://andersmurphy.com/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="https://andersmurphy.com/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Clojure: code as data</h1><time class="post-date" datetime="2020-03-01T00:00:00+00:00">01 Mar 2020</time><p>In Clojure, the primary representation of code is the S-expression that takes the form of nested sequences (lists and vectors). The majority of Clojure's functions are designed to operate on sequences. As a result, Clojure code can be manipulated using the same functions that are used to manipulate Clojure data. In other words, there is no distinction between code and data. Code is data. This property is known as <a href='https://en.wikipedia.org/wiki/Homoiconicity'>homoiconicity</a>. This article will explore this concept.</p><h2 id="code&#95;equality">Code equality</h2><p>We can check two pieces of code for equality by turning the code into data with a <code>'</code> symbol and then comparing them with <code>=</code>:</p><pre><code class="clojure"><span class="dim">&#40;</span>= '<span class="dim">&#40;</span>map inc items<span class="dim">&#41;</span>
   '<span class="dim">&#40;</span>map inc items<span class="dim">&#41;&#41;</span>
<span class="dim">
=&gt;</span> true

<span class="dim">&#40;</span>= '<span class="dim">&#40;</span>map inc items<span class="dim">&#41;</span>
   '<span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
<span class="dim">
=&gt;</span> false
</code></pre><p>Simple.</p><h2 id="code&#95;diff">Code diff</h2><p>We can use <code>clojure.data/diff</code> to find out the difference between these two pieces of code:</p><pre><code class="clojure"><span class="dim">&#40;</span>clojure.data/diff '<span class="dim">&#40;</span>map inc items<span class="dim">&#41;</span>
                   '<span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
<span class="dim">
=&gt;</span> &#91;&#91;nil inc&#93; &#91;nil dec&#93; &#91;map nil items&#93;&#93;
</code></pre><p>From this we can see that the second item in the expression is different. But what happens with nested code?</p><pre><code class="clojure"><span class="dim">&#40;</span>clojure.data/diff '<span class="dim">&#40;</span>when activate?
                      <span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
                   '<span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
<span class="dim">
=&gt;</span> &#91;&#91;when activate? <span class="dim">&#40;</span>map dec items<span class="dim">&#41;</span>&#93; &#91;map dec items&#93; nil&#93;
</code></pre><p>Looks like the <code>diff</code> function doesn't recognise the commonality between these two pieces of code.</p><h2 id="commonality&#95;with&#95;tree-seq">Commonality with tree-seq</h2><p>The <code>tree-seq</code> function returns a lazy sequence of the nodes in a tree, via a depth-first walk. It takes two functions and the root node of a tree. The first function needs to return <code>true</code> if the node is a branch (can have children); in this case we use <code>coll?</code> which returns <code>true</code> if the node is a collection. The second function will be called on these branch nodes; in this case <code>seq</code> which returns a sequence of the children of that node or <code>nil</code> if there are none:</p><pre><code class="clojure"><span class="dim">&#40;</span>tree-seq coll? seq '<span class="dim">&#40;</span>when activate?
                       <span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;&#41;</span>
<span class="dim">
=&gt;</span>
<span class="dim">&#40;&#40;</span>when activate? <span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
 when
 activate?
 <span class="dim">&#40;</span>map dec items<span class="dim">&#41;</span>
 map
 dec
 items<span class="dim">&#41;</span>
</code></pre><p>We can use <code>tree-seq</code> to build a sequence of each node for two pieces of code and then compare each node using a <code>for</code> comprehension, filtering the results which are equal:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>find-common-code</strong> &#91;code-a code-b&#93;
  <span class="dim">&#40;</span>-&gt; <span class="dim">&#40;</span>for &#91;a     <span class="dim">&#40;</span>tree-seq coll? seq code-a<span class="dim">&#41;</span>
            b     <span class="dim">&#40;</span>tree-seq coll? seq code-b<span class="dim">&#41;</span>
            :when <span class="dim">&#40;</span>= a b<span class="dim">&#41;</span>&#93;
        a<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>find-common-code '<span class="dim">&#40;</span>when activate?
                     <span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
                  '<span class="dim">&#40;</span>map dec items<span class="dim">&#41;&#41;</span>
<span class="dim">
=&gt;</span> <span class="dim">&#40;&#40;</span>map dec items<span class="dim">&#41;</span> map dec items<span class="dim">&#41;</span>
</code></pre><p>This returns the common nodes: <code>&#40;map dec items&#41;</code>, <code>map</code>, <code>dec</code> and <code>items</code>.</p><h2 id="refactoring&#95;common&#95;code">Refactoring common code</h2><p>Here we have some of the code used to generate the RSS feed for this blog:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>generate-feed-items</strong> &#91;posts&#93;
  <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
         <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
           &#91;:item
            &#91;:title post-name&#93;
            &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
            &#91;:link post-url&#93;
            &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
       posts<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>defn <strong>generate-rss-feed</strong> &#91;posts&#93;
  <span class="dim">&#40;</span>xml/sexp-as-element
   &#91;:rss
    {:version    &quot;2.0&quot;
     :xmlns:atom &quot;https://www.w3.org/2005/Atom&quot;
     :xmlns:dc   &quot;https://purl.org/dc/elements/1.1/&quot;}
    &#91;:channel
     &#91;:title site-title&#93;
     &#91;:description site-tagline&#93;
     &#91;:link site-url&#93;
     &#91;:atom:link
      {:href site-rss :rel &quot;self&quot; :type &quot;application/rss+xml&quot;}&#93;
     <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
            <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
              &#91;:item
               &#91;:title post-name&#93;
               &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
               &#91;:link post-url&#93;
               &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
          posts<span class="dim">&#41;</span>&#93;&#93;<span class="dim">&#41;&#41;</span>
</code></pre><p>We think some of the code might be duplicated and we want to refactor it out. With what we have just learnt, we can write a function to find the largest piece of common code.</p><p>First, we need a function to define the largest piece of code. We decide to use string length as a simple heuristic:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>code-string-length</strong> &#91;code&#93;
    <span class="dim">&#40;</span>count <span class="dim">&#40;</span>str code<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>sort-by code-string-length &gt; '<span class="dim">&#40;&#40;</span>+ 1 2 3<span class="dim">&#41;</span> <span class="dim">&#40;</span>&#42; 1 200<span class="dim">&#41;</span> <span class="dim">&#40;</span>map inc &#91;1 2 3 4&#93;<span class="dim">&#41;&#41;&#41;</span>
<span class="dim">
=&gt;</span> <span class="dim">&#40;&#40;</span>map inc &#91;1 2 3 4&#93;<span class="dim">&#41;</span> <span class="dim">&#40;</span>+ 1 2 3<span class="dim">&#41;</span> <span class="dim">&#40;</span>&#42; 1 200<span class="dim">&#41;&#41;</span>
</code></pre><p>The <code>find-largest-common-code</code> uses <code>tree-seq</code> to get a sequence of nodes and then <code>frequencies</code> to find duplicates. We also make sure these duplicates are collections as we aren't interested in duplicates variable names, strings etc. Finally, we order by our string length heuristic and pick the first item:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>find-largest-common-code</strong> &#91;code&#93;
  <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>tree-seq coll? seq code<span class="dim">&#41;</span>
       frequencies
       <span class="dim">&#40;</span>keep <span class="dim">&#40;</span>fn &#91;&#91;code freq&#93;&#93;
               <span class="dim">&#40;</span>when <span class="dim">&#40;</span>and <span class="dim">&#40;</span>&gt; freq 1<span class="dim">&#41;</span> <span class="dim">&#40;</span>coll? code<span class="dim">&#41;&#41;</span>
                 code<span class="dim">&#41;&#41;&#41;</span>
       <span class="dim">&#40;</span>sort-by code-string-length &gt;<span class="dim">&#41;</span>
       first<span class="dim">&#41;&#41;</span>
</code></pre><p>Trying this out on our large piece of code returns the largest duplicate:</p><pre><code class="clojure"><span class="dim">&#40;</span>find-largest-common-code
   '<span class="dim">&#40;&#40;</span>defn <strong>generate-feed-items</strong> &#91;posts&#93;
       <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
              <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
                &#91;:item
                 &#91;:title post-name&#93;
                 &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
                 &#91;:link post-url&#93;
                 &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
            posts<span class="dim">&#41;&#41;</span>

     <span class="dim">&#40;</span>defn <strong>generate-rss-feed</strong> &#91;posts&#93;
       <span class="dim">&#40;</span>xml/sexp-as-element
        &#91;:rss
         {:version    &quot;2.0&quot;
          :xmlns:atom &quot;https://www.w3.org/2005/Atom&quot;
          :xmlns:dc   &quot;https://purl.org/dc/elements/1.1/&quot;}
         &#91;:channel
          &#91;:title site-title&#93;
          &#91;:description site-tagline&#93;
          &#91;:link site-url&#93;
          &#91;:atom:link
           {:href site-rss :rel &quot;self&quot; :type &quot;application/rss+xml&quot;}&#93;
          <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
                 <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
                   &#91;:item
                    &#91;:title post-name&#93;
                    &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
                    &#91;:link post-url&#93;
                    &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
               posts<span class="dim">&#41;</span>&#93;&#93;<span class="dim">&#41;&#41;&#41;&#41;</span>
<span class="dim">
=&gt;</span>
<span class="dim">&#40;</span>map
 <span class="dim">&#40;</span>fn
  &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
  <span class="dim">&#40;</span>let
   &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
   &#91;:item
    &#91;:title post-name&#93;
    &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
    &#91;:link post-url&#93;
    &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
 posts<span class="dim">&#41;</span>
</code></pre><p>We can then refactor our code accordingly:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>generate-feed-items</strong> &#91;posts&#93;
  <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
         <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
           &#91;:item
            &#91;:title post-name&#93;
            &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
            &#91;:link post-url&#93;
            &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
       posts<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>defn <strong>generate-rss-feed</strong> &#91;posts&#93;
  <span class="dim">&#40;</span>xml/sexp-as-element
   &#91;:rss
    {:version    &quot;2.0&quot;
     :xmlns:atom &quot;https://www.w3.org/2005/Atom&quot;
     :xmlns:dc   &quot;https://purl.org/dc/elements/1.1/&quot;}
    &#91;:channel
     &#91;:title site-title&#93;
     &#91;:description site-tagline&#93;
     &#91;:link site-url&#93;
     &#91;:atom:link
      {:href site-rss :rel &quot;self&quot; :type &quot;application/rss+xml&quot;}&#93;
     <span class="dim">&#40;</span>generate-feed-items posts<span class="dim">&#41;</span>&#93;&#93;<span class="dim">&#41;&#41;</span>

</code></pre><p>Much better!</p><h2 id="a&#95;macro&#95;implementation">A macro implementation</h2><p>If we don't want to pass the code as a quoted list, we can change the <code>find-largest-common-code</code> function into a macro:</p><pre><code class="clojure"><span class="dim">&#40;</span>defmacro <strong>find-largest-common-code</strong> &#91;&amp; body&#93;
  `<span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>tree-seq coll? seq &#126;body<span class="dim">&#41;</span>
        frequencies
        <span class="dim">&#40;</span>keep <span class="dim">&#40;</span>fn &#91;&#91;code freq&#93;&#93;
                <span class="dim">&#40;</span>when <span class="dim">&#40;</span>and <span class="dim">&#40;</span>&gt; freq 1<span class="dim">&#41;</span> <span class="dim">&#40;</span>coll? code<span class="dim">&#41;&#41;</span>
                  code<span class="dim">&#41;&#41;&#41;</span>
        <span class="dim">&#40;</span>sort-by code-string-length &gt;<span class="dim">&#41;</span>
        first<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>find-largest-common-code
 <span class="dim">&#40;</span>defn <strong>generate-feed-items</strong> &#91;posts&#93;
   <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
          <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
            &#91;:item
             &#91;:title post-name&#93;
             &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
             &#91;:link post-url&#93;
             &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
        posts<span class="dim">&#41;&#41;</span>

 <span class="dim">&#40;</span>defn <strong>generate-rss-feed</strong> &#91;posts&#93;
   <span class="dim">&#40;</span>xml/sexp-as-element
    &#91;:rss
     {:version    &quot;2.0&quot;
      :xmlns:atom &quot;https://www.w3.org/2005/Atom&quot;
      :xmlns:dc   &quot;https://purl.org/dc/elements/1.1/&quot;}
     &#91;:channel
      &#91;:title site-title&#93;
      &#91;:description site-tagline&#93;
      &#91;:link site-url&#93;
      &#91;:atom:link
       {:href site-rss :rel &quot;self&quot; :type &quot;application/rss+xml&quot;}&#93;
      <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
             <span class="dim">&#40;</span>let &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
               &#91;:item
                &#91;:title post-name&#93;
                &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
                &#91;:link post-url&#93;
                &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
           posts<span class="dim">&#41;</span>&#93;&#93;<span class="dim">&#41;&#41;&#41;</span>
<span class="dim">
=&gt;</span>
<span class="dim">&#40;</span>map
 <span class="dim">&#40;</span>fn
  &#91;{:keys &#91;post-name date post-path-name&#93;}&#93;
  <span class="dim">&#40;</span>let
   &#91;post-url <span class="dim">&#40;</span>str site-url &quot;/&quot; post-path-name<span class="dim">&#41;</span>&#93;
   &#91;:item
    &#91;:title post-name&#93;
    &#91;:pubDate <span class="dim">&#40;</span>date-&gt;rfc822 date<span class="dim">&#41;</span>&#93;
    &#91;:link post-url&#93;
    &#91;:guid {:isPermaLink &quot;true&quot;} post-url&#93;&#93;<span class="dim">&#41;&#41;</span>
 posts<span class="dim">&#41;</span>
</code></pre><p>Hopefully, this example helps illustrate the value of code as data (homoiconicity).</p></article><div class="footer"><p>© 2015-2024 Anders Murphy</p></div></div></body></html>