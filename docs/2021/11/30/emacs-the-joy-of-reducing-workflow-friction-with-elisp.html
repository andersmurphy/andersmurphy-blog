<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>2021/11/30/emacs-the-joy-of-reducing-workflow-friction-with-elisp.html</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="https://andersmurphy.com/styles.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/theme.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="https://andersmurphy.com/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="https://andersmurphy.com/assets/anderspixel.png" width="60" /><h1><a href="https://andersmurphy.com/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="https://andersmurphy.com/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Emacs: the joy of reducing workflow friction with elisp</h1><time class="post-date" datetime="2021-11-30T00:00:00+00:00">30 Nov 2021</time><p>Emacs is an interactive, self-documenting and extensible elisp interpreter. This makes it surprisingly enjoyable to extend. It goes something like this: you notice some friction when using a command, you use Emacs' self-documenting features to learn about the command, you investigate the source, you write some elisp, you evaluate it and you try the new and improved command out (all without ever having to restart Emacs).</p><p>Over time you get more adventurous as your knowledge of Emacs and elisp grows. Your write commands that reach further, you put up with less and less friction after all this is your development environment why not make yourself at home? You've also somehow become surprisingly good at elisp. For me this is the magic of Emacs.</p><p>Let's walk through an example.</p><h2 id="identify&#95;friction">Identify friction</h2><p>You know when you copy something with <code>ctrl+v/cmd+v</code> and realise too late that you've now lost the previous thing you had copied? Well Emacs doesn't have that problem because all your copies get added to a list that you can cycle through by pressing <code>M-y</code> (<code>alt+y/opt+v</code>). This is a fantastic feature, but it only work when you press it straight after pasting some text. In this example that awkwardness is the friction we want to remove.</p><h2 id="imagine&#95;how&#95;it&#95;should&#95;work">Imagine how it should work</h2><p>What if when we called the paste command consecutively it started cycling through the list of copies? Rather than inserting another copy.</p><p>What behaviour would this proposed solution interfere with? Pasting the same thing multiple times in a row? How often do you paste the same thing multiple times in a row? In my case almost never, even then I would probably issue a different command between pastes. So in theory this will be a net improvement to my workflow (it doesn't always play out like this in practice).</p><h2 id="explore&#95;documentation&#95;and&#95;source">Explore documentation and source</h2><p>Lets find out what function is called when we type <code>M-y</code>. We can ask Emacs to describe a key by typing <code>C-h k</code> followed by the keys we want to describe, in this case <code>M-y</code>. This will bring up a help buffer with useful information about that key.</p><pre><code>M-y runs the command yank-pop &#40;found in global-map&#41;, which is an
interactive compiled Lisp function in ‘simple.el’.
</code></pre><p><code>yank-pop</code> is the name of the function called when we press <code>M-y</code>. <code>yank</code> is Emacs name for paste. Emacs has arcane names for things as many of the names we use in software today like copy and paste were not standard when these features were implemented in Emacs.</p><p>This help buffer also has a direct link to the function in the <code>simple.el</code> source file. If we follow that link we will be able to see the elisp implementation.</p><pre><code class="elisp">&#40;defun <strong>yank-pop</strong> &#40;&amp;optional arg&#41;
  &quot;Replace just-yanked stretch...
  &#40;interactive &quot;p&quot;&#41;
  &#40;if &#40;not &#40;eq last-command 'yank&#41;&#41;
      ...&#41;&#41;
</code></pre><p>From this source code we can see how to call different functions based on the last command. Let's see the documentation for <code>last-command</code> by typing <code>C-h v last-command</code>.</p><pre><code>...

The last command executed.
Normally a symbol with a function definition, but can be whatever was found
in the keymap, or whatever the variable ‘this-command’ was set to by that
command.

...
</code></pre><p>We now have enough understanding to start writing some elisp code.</p><h2 id="write&#95;some&#95;elisp">Write some elisp</h2><p>Putting this all together we can create a new function called <code>yank++</code>. We do this in the <code>&#42;scratch&#42;</code> buffer. This is a elisp buffer for writing, evaluating and testing arbitrary elisp code.</p><pre><code class="elisp">&#40;defun <strong>yank++</strong> &#40;&#41;
  &quot;Like 'yank'. But calling 'yank' again will call 'yank-pop'.&quot;
  &#40;interactive&#41;
  &#40;if &#40;member last-command '&#40;yank yank-pop&#41;&#41;
      &#40;yank-pop&#41;
    &#40;yank&#41;&#41;&#41;
</code></pre><p>This function calls <code>yank-pop</code> if the value of <code>last-command</code> is a <code>member</code> of the list <code>&#40;yank yank-pop&#41;</code> i.e the last command was <code>yank</code> or <code>yank-pop</code>. Otherwise it calls <code>yank</code>.</p><h2 id="evaluate,&#95;bind&#95;and&#95;test&#95;the&#95;function">Evaluate, bind and test the function</h2><p>Place the cursor at the end of the <code>yank++</code> function (the <code>|</code> symbol below represents the cursor) and type <code>C-x C-e</code> to evaluate the code. This will 'load' this new function into Emacs.</p><pre><code class="elisp">&#40;defun <strong>yank++</strong> &#40;&#41;
  &quot;Like 'yank'. But calling 'yank' again will call 'yank-pop'.&quot;
  &#40;interactive&#41;
  &#40;if &#40;member last-command '&#40;yank yank-pop&#41;&#41;
      &#40;yank-pop&#41;
    &#40;yank&#41;&#41;&#41;|
</code></pre><p>To bind the function to a key write the following elisp code and evaluate it like we did above with <code>C-x C-e</code>.</p><pre><code class="elisp">&#40;global-set-key &#40;kbd &quot;C-y&quot;&#41; 'yank++&#41;
</code></pre><p>Now try pasting something with <code>C-y</code> and see what happens when you press it multiple times. You should see it cycle through all the things you have previously copied.</p><p>Once you are happy with the results you can persist these changes by adding both the <code>yank++</code> function and the key-binding to your <code>init.el</code> file.</p><h2 id="profit">Profit</h2><p>This example barely scratches the surface of what you can do when extending Emacs. But hopefully it still illustrates a valuable point.</p><p>Emacs is great at reducing friction because there is so little friction to extending Emacs. The distance between an idea and a working implementation is so short you barely have to reach. In Emacs friction is only a problem so long as you don't notice it. The minute you do you can spend a few minute writing elisp and make it disappear.</p></article><div class="footer"><p>© 2015-2021 Anders Murphy</p></div></div></body></html>