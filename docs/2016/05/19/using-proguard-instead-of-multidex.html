<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Using Proguard instead of multidex</title><link href="https://andersmurphy.com/styles.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/theme.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/nord.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/clojure.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link href="https://andersmurphy.com/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="https://andersmurphy.com/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" src="https://andersmurphy.com/assets/anderspixel.png" /><h1><a href="https://andersmurphy.com">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="https://andersmurphy.com/feed.xml">RSS</a></nav><p>Â© 2015-2020 Anders Murphy</p></div></div><div class="content container"><article class="post"><h1 class="post-title">Using Proguard instead of multidex</h1><time class="post-date" datetime="2016-05-19T00:00:00+00:00">19 May 2016</time><p>One of the downsides of using MultiDex to overcome "The 65k limit" is that build times can increase significantly. Another option is to use <a href='http://proguard.sourceforge.net/'>ProGuard</a>. ProGuard overcomes "The 65k limit" by removing unused method references, this can make a big difference if you are using large third party libraries like <a href='https://github.com/google/guava'>Guava</a>. If configured correctly (disabling optimization/obfuscation) ProGuard can have little to no negative <a href='https://image.slidesharecdn.com/jackandjilldroidconlondon2015-160314154239/95/eric-lafortune-the-jack-and-jill-build-system-16-638.jpg?cb=1457972343'>impact on your build times</a> (in the case of larger project it can even decrease build time).</p><p><!&ndash;more&ndash;></p><h2>Step 1: Create ProGuard main file</h2><p>Create a file named <strong>proguard-main.pro</strong> in the app level of your project directory. This file is where you add proguard settings that are shared between your debug and release builds.</p><h2>Step 2: Create ProGuard debug header file</h2><p>Create a file named <strong>proguard-header-debug.pro</strong> in the app level of your project directory. This file is where you add proguard settings that are specific to debug builds.</p><pre><code class="bash">-dontoptimize
-dontobfuscate
</code></pre><p>We have added <code>-dontoptimize</code> to disable code optimization and <code>-dontobfuscate</code> to disable obfuscation. If these were not disabled the debugger would struggle to find the executable code that maps to your source and if it did it would be hard to decipher as the code would be obfuscated. Disabling optimization/obfuscation also means that ProGuard will have little to no impact on build times.</p><h2>Step 3: Create ProGuard release header file</h2><p>Create a file named <strong>proguard-header-release.pro</strong> in the app level of your project directory. This file is where you add proguard settings that are specific to release builds.</p><pre><code class="bash">-optimizationpasses 5
-optimizations !code/simplification/arithmetic,!field/&#42;,!class/merging/&#42;
</code></pre><p>We have specified the number of optimization passes and which optimizations ProGuard should do. More importantly we have removed <code>-dontoptimize</code> and <code>-dontobfuscate</code> meaning this build will be optimized and obfuscated.</p><h2>Step 4: Update the app build.gradle</h2><p>Update your app's the buildTypes block in your <strong>build.gradle</strong> file as shown below.</p><pre><code class="groovy">buildTypes {
    release {
        minifyEnabled true
        signingConfig signingConfigs.release
        proguardFiles getDefaultProguardFile&#40;'proguard-android.txt'&#41;, 'proguard-header-release.pro', 'proguard-main.pro'
    }
    debug {
        minifyEnabled true
        proguardFiles getDefaultProguardFile&#40;'proguard-android.txt'&#41;, 'proguard-header-debug.pro', 'proguard-main.pro'
    }
}
</code></pre><p>The release build uses the release header file and the debug build uses the debug header file. We have also set <code>minifyEnabled true</code> in both builds. This means that regardless of which build we are using ProGuard will strip out any unused method references. This should keep your app bellow "The 65k limit" even if you are using large third party libraries. More importantly, if set up in this way, ProGuard will have little to no negative <a href='https://image.slidesharecdn.com/jackandjilldroidconlondon2015-160314154239/95/eric-lafortune-the-jack-and-jill-build-system-16-638.jpg?cb=1457972343'>impact on your build times</a> (unlike MultiDex), keeping your development feedback loop tight.</p><p>Check out <a href='https://github.com/andersmurphy/chain/commit/9d2241a2a6d2571696a1d3ad5ba37e521d8641f5'>this project</a> for an example of how to set up ProGuard in your app.</p></article></div></body></html>