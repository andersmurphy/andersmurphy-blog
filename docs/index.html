<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Anders Murphy</title><link href="https://andersmurphy.com/styles.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/theme.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/nord.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/clojure.min.js"></script><script>hljs.initHighlightingOnLoad();</script><link href="https://andersmurphy.com/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="https://andersmurphy.com/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" src="https://andersmurphy.com/assets/anderspixel.png" /><h1><a href="https://andersmurphy.com">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="https://andersmurphy.com/feed.xml">RSS</a></nav><p>Â© 2015-2020 Anders Murphy</p></div></div><div class="content container"><div class="posts"><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/10/11/clojure-previous-current-and-next.html">Clojure: previous, current and next</a></h1><time class="post-date" datetime="2020-10-11T00:00:00+00:00">11 Oct 2020</time><p>This article will cover the common pattern of iterating over a list of items whilst keeping a reference to the previous, current and next item.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/09/06/clojure-jdbc-using-any-and-all-as-an-alternative-to-in.html">Clojure: jdbc using any and all as alternatives to in</a></h1><time class="post-date" datetime="2020-09-06T00:00:00+00:00">06 Sep 2020</time><p><a href='https://github.com/seancorfield/next-jdbc'>next-jdbc</a> uses parameterised queries to prevent SQL Injections. These queries can take parameters by passing question marks (?) in the query and then by replacing each question mark index with required values. However this can make some sql operators more challenging to use programmatically. In particular <code>in&#40;?,?,?&#41;</code>. In this post we cover using <a href='https://www.postgresql.org/'>postgresql</a>'s <code>any&#40;?&#41;</code> and <code>all&#40;?&#41;</code> to get around this.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/08/20/emacs-setting-up-apheleia-to-use-zprint.html">Emacs: setting up Apheleia to use Prettier and Zprint</a></h1><time class="post-date" datetime="2020-08-20T00:00:00+00:00">20 Aug 2020</time><p><a href='https://github.com/raxod502/apheleia'>Apheleia</a> is an awesome Emacs package for formatting code quickly using external command line tools like <code>prettier</code>. Not only is it fast but it also does a great job at maintaining point position relative to its surroundings (which has been one of my minor frustrations with other Emacs formatters) . Its also language agnostic so you can use it with any language that has a command line formatting tool. This post will cover setting up apheleia with <a href='https://github.com/prettier/prettier'>prettier</a> (for JavaScript) and <a href='https://github.com/kkinnear/zprint'>zprint</a> (for Clojure).</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/08/18/homebrew-write-your-own-brew-formula.html">Homebrew: write your own brew formula</a></h1><time class="post-date" datetime="2020-08-18T00:00:00+00:00">18 Aug 2020</time><p><a href='https://www.graalvm.org/'>GraalVM</a> is a recent development in the Java ecosystem that allows you to generate native binaries for applications that run on the Java Virtual Machine (JVM). One of the main advantages of this is that it gets around the JVMs slow startup time which is a problem for short lived programs that are run often. This has lead to a projects like <a href='https://github.com/kkinnear/zprint/releases/tag/1.0.0'>zprint releasing native binaries</a>. This is great but, it doesn't give you a nice reproducible way to install/manage/uninstall these executables. For that we want a package manager like <a href='https://brew.sh/'>homebrew</a>.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/08/16/clojure-code-formatting-pre-commit-hook-with-zprint.html">Clojure: code formatting pre-commit hook with zprint</a></h1><time class="post-date" datetime="2020-08-16T00:00:00+00:00">16 Aug 2020</time><p>As a codebase and the team working on it grows, it helps to keep the formatting of a project consistent. This makes the code easier to read and removes the need for unnecessary formatting debates on pull requests. One way to achieve this is to add a formatting check to your continuous integration pipeline. The problem with this solution is that it can add unnecessary overhead. You push a commit, the continuous integration job fails due to incorrect formatting, you fix the formatting issue, and push a new commit. Why can't the formatter just fix the issue itself and save you the trouble? This article will cover setting up <a href='https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks'>pre-commit</a> to automatically format Clojure code with <a href='https://github.com/kkinnear/zprint'>zprint</a> to achieve a more streamlined workflow.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/03/27/clojure-java-interop-with-bean.html">Clojure: java interop with bean</a></h1><time class="post-date" datetime="2020-03-27T00:00:00+00:00">27 Mar 2020</time><p>One of the great things with Clojure is that it has fantastic java interop. In this article we explore the <code>bean</code> function and how it makes working with java objects more idiomatic.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/03/01/clojure-code-as-data.html">Clojure: code as data</a></h1><time class="post-date" datetime="2020-03-01T00:00:00+00:00">01 Mar 2020</time><p>In Clojure, the primary representation of code is the S-expression that takes the form of nested sequences (lists and vectors). The majority of Clojure's functions are designed to operate on sequences. As a result, Clojure code can be manipulated using the same functions that are used to manipulate Clojure data. In other words, there is no distinction between code and data. Code is data. This property is known as <a href='https://en.wikipedia.org/wiki/Homoiconicity'>homoiconicity</a>. This article will explore this concept.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2020/02/08/clojure-persistent-rate-limiting.html">Clojure: persistent rate limiting</a></h1><time class="post-date" datetime="2020-02-08T00:00:00+00:00">08 Feb 2020</time><p>Some business needs require you to limit the number of times you do something. An example of this would be sending a daily email to users. You could achieve this by making sure you run the function only once per day. However, if that function were to crash part way through how would you know which users had already been sent their daily email and which hadn't? Resolving this without sending some users multiple emails could be a large time sink. A more robust solution would be to make the email sending function idempotent; meaning the effects of the function are applied only once per user per day and any additional applications do nothing. This article will explore one approach to solving this problem in Clojure.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2019/12/19/clojure-permutations.html">Clojure: permutations</a></h1><time class="post-date" datetime="2019-12-19T00:00:00+00:00">19 Dec 2019</time><p>I was solving an <a href='https://adventofcode.com/'>Advent of Code</a> problem and part of the solution required generating all the permutations of a set of numbers. Permutation is the act of arranging the members of a set into different orders. I wanted to write a recursive solution rather than an imperative solution. After some searching I found a <a href='https://en.wikipedia.org/wiki/Scheme_programming_language'>Scheme</a> implementation. As Scheme and Clojure are both dialects of Lisp, translating one into the other wasn't too difficult.</p></article><article class="post"><h1 class="post-title"><a href="https://andersmurphy.com/2019/12/07/ruby-functional-programming.html">Ruby: functional programming</a></h1><time class="post-date" datetime="2019-12-07T00:00:00+00:00">07 Dec 2019</time><p>In one of my previous jobs I worked as a full stack engineer on a codebase with a Ruby backend and a Javascript/React frontend. Having used Clojure a fair bit in my spare time I was keen to code in a functional style. At first glance this seems tricky in Ruby as it doesn't have first class functions.</p></article></div><div class="pagination"><div class="pagination-item"><a href="https://andersmurphy.com/page/2.html">-></a></div></div></div></body></html>