<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: SQLite application defined SQL functions with JDBC</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="https://andersmurphy.com/styles.css" rel="stylesheet" type="text/css" /><link href="https://andersmurphy.com/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="https://andersmurphy.com/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="https://andersmurphy.com/assets/anderspixel.png" width="60" /><h1><a href="https://andersmurphy.com/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="https://andersmurphy.com/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Clojure: SQLite application defined SQL functions with JDBC</h1><time class="post-date" datetime="2023-07-16T00:00:00+00:00">16 Jul 2023</time><p>SQLite provides a convenient interface called <a href='https://www.sqlite.org/appfunc.html'>Application-Defined SQL Functions</a> that lets you create custom SQL functions that call back into your application code to compute their results. This lets us  extend SQLite in Clojure. Want to query with regex or jsonpath? Want custom aggregation functions? Don't want to write C? Don't want to manage different precompiled binaries for different operating systems. No problem Application Defined SQL Functions have you covered. </p><h2 id="in&#95;java">In Java</h2><p> <a href='https://github.com/xerial/sqlite-jdbc'>org.sqlite</a> provides an abstract class <code>org.sqlite.Function</code> for implementing application defined  SQL functions.</p><p>Bellow is how <code>org.sqlite.Function</code> is intended to be used from java using an anonymous class that extends <code>org.sqlite.Function</code>.</p><pre><code>Function.create&#40;conn, &quot;hello&#95;world&quot;, new Function&#40;&#41; {
 @Override
 protected void xFunc&#40;&#41; {
   result&#40;&quot;Hello, world!&quot;&#41;
 }
}, 0, Function.FLAG&#95;DETERMINISTIC&#41;;
</code></pre><h2 id="in&#95;clojure">In Clojure</h2><p>Clojure provides the <code>proxy</code> function for creating anonymous classes. However, it doesn't allow you to access protected super methods, and unfortunately <code>org.sqlite.Function</code>  implements a bunch of methods as protected. So we will need to use the <code>gen-class</code> macro.</p><h3 id="create&#95;a&#95;gen-class">Create a gen-class</h3><p><code>gen-class</code> creates named classes for direct use as Java classes and allows us to expose inherited protected methods.</p><pre><code class="Clojure">&#40;gen-class
  :name sqlite.db.application-defined-functions.RegexCapture
  :prefix &quot;regex-capture-&quot;
  :extends org.sqlite.Function
  :exposes-methods {result superResult
                    value&#95;text superValueText}&#41;
</code></pre><p>We extend <code>org.sqlite.Function</code> and expose the methods <code>result</code> and <code>value&#95;text</code> binding them to <code>superResult</code> and <code>superValueText</code> respectively.</p><h3 id="override&#95;xfunc">Override xFunc</h3><p>We use <code>defn</code> to override the <code>org.sqlite.Function</code> class's <code>xFunc</code> method. It's important to note that the function name prefix must match the prefix specified in <code>gen-class</code> under <code>:prefix</code>. In this case that's <code>regex-capture-</code>.</p><pre><code class="Clojure">&#40;defn <strong>regex-capture-xFunc</strong> &#91;this&#93;
  &#40;.superResult this
    &#40;let &#91;result &#40;re-find
                   &#40;re-pattern
                     &#40;.superValueText  this 0&#41;&#41;
                   &#40;.superValueText  this 1&#41;&#41;&#93;
      &#40;if &#40;vector? result&#41;
        &#40;second result&#41;
        result&#41;&#41;&#41;&#41;
</code></pre><h3 id="create&#95;a&#95;directory&#95;called&#95;classes">Create a directory called classes</h3><p>Ensure the default target output directory <code>classes</code> exists at the top level of the project.</p><h3 id="add&#95;classes&#95;directory&#95;to&#95;paths">Add classes directory to paths</h3><p>Add the classes directory to the class path in <code>deps.edn</code>.</p><pre><code class="Clojure">{:paths   &#91;&quot;src&quot; &quot;classes&quot;&#93;
 :deps
 {org.clojure/clojure               {:mvn/version &quot;1.11.1&quot;}
  com.github.seancorfield/next.jdbc {:mvn/version &quot;1.3.874&quot;}
  org.xerial/sqlite-jdbc            {:mvn/version &quot;3.42.0.0&quot;}}
 :aliases {}}
</code></pre><h3 id="generate&#95;the&#95;classes">Generate the classes</h3><p>Compile to generate classes using the <code>compile</code> function.</p><pre><code>&#40;compile 'sqlite.db.application-defined-functions&#41;
</code></pre><h3 id="tests&#95;the&#95;sql&#95;functions">Tests the SQL functions</h3><p>To use the application defined SQL functions we need to create them. This loads them into SQLite for the duration of the current connection, meaning they can be used in any query that uses the same connection.</p><pre><code class="Clojure">&#40;let &#91;my-datasource &#40;jdbc/get-datasource
                      {:jdbcUrl &quot;jdbc:sqlite:db/database.db&quot;}&#41;&#93;
  &#40;with-open &#91;conn &#40;jdbc/get-connection my-datasource&#41;&#93;
    &#40;Function/create
      conn
      &quot;regex&#95;capture&quot;
      &#40;sqlite.db.application-defined-functions.RegexCapture.&#41;&#41;
    &#40;jdbc/execute! conn
      &#91;&quot;select regex&#95;capture&#40;?, 'Hello, world!'&#41;&quot;
       &quot;, &#40;world&#41;!&quot;&#93;&#41;&#41;&#41;

=&gt;
&#91;{:regex&#95;capture&#40;?, 'Hello, world!'&#41; &quot;world&quot;}&#93;
</code></pre><p>Magic! SQLite is executing functions defined in Clojure.</p><h3 id="bonus:&#95;automatically&#95;compile&#95;the&#95;sql&#95;functions">Bonus: Automatically compile the SQL functions</h3><p>To compile our SQLite function on repl launch add the following <code>:main-opts</code> to the <code>:dev</code> alias.</p><pre><code>{:paths   &#91;&quot;src&quot; &quot;classes&quot;&#93;
 :deps
 {org.clojure/clojure               {:mvn/version &quot;1.11.1&quot;}
  com.github.seancorfield/next.jdbc {:mvn/version &quot;1.3.874&quot;}
  org.xerial/sqlite-jdbc            {:mvn/version &quot;3.42.0.0&quot;}}
 :aliases
 {:dev
  {:main-opts
   &#91;;; Ensures application defined functions are compiled
    ;; As they use gen-class to extend org.sqlite.Function
    &quot;-e&quot; &quot;&#40;compile 'sqlite.db.application-defined-functions&#41;&quot;
    &quot;-r&quot;&#93;}}}
</code></pre><p>This means we don't have to remember to manually compile the SQLite functions (unless you change them during a repl session).</p><p>The full example <a href='https://github.com/andersmurphy/clj-cookbook/tree/master/sqlite/application-defined-sql-functions'>project can be found here</a>.</p><p>In a subsequent post I'll be sharing a helper macro that makes writing Application Defined SQL functions more convenient and more performant.</p></article><div class="footer"><p>Â© 2015-2024 Anders Murphy</p></div></div></body></html>