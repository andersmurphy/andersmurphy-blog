<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: virtual threads with ring and http-kit</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="/styles.css" rel="stylesheet" type="text/css" /><link href="/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="/assets/anderspixel.png" width="60" /><h1><a href="/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Clojure: virtual threads with ring and http-kit</h1><time class="post-date" datetime="2023-09-15T00:00:00+00:00">15 Sep 2023</time><p><a href='https://openjdk.org/jeps/425'>Java 19 introduce virtual threads</a> as a preview feature. Virtual threads are lightweight threads that allow you to write server applications in a simple thread-per-request style (as opposed to async style) and still scale with near-optimal hardware utilisation. The thread-per-request approach is generally easier to reason about, maintain and debug than it's asynchronous counterparts. In this post we'll cover configuring <a href='https://github.com/http-kit/http-kit'>http-kit</a> to make your ring handlers use virtual threads and benchmark it against regular threads to show how it alleviates the need for tuning thread pools.</p><p>If you're running Java 19+ you can enable preview features with <code>--enable-preview</code> as shown below. This step won't be needed in Java 21 (which is being released this month) as virtual threads will be out of preview and available by default.</p><pre><code class="Clojure">{:paths   &#91;&quot;src&quot;&#93;
 :deps    {...}
 :aliases {:dev {:jvm-opts &#91;&quot;--enable-preview&quot;&#93;}}}
</code></pre><p>Set up a ring handler that sleeps for 50 milliseconds to simulate a long request.</p><pre><code class="Clojure"><span class="dim">&#40;</span>ns <strong>server.core</strong>
  <span class="dim">&#40;</span>:gen-class<span class="dim">&#41;</span>
  <span class="dim">&#40;</span>:require &#91;org.httpkit.server :as hk-server&#93;
            ...<span class="dim">&#41;</span>
  <span class="dim">&#40;</span>:import <span class="dim">&#40;</span>java.util.concurrent Executors<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>def <strong>app</strong>
  <span class="dim">&#40;</span>ring/ring-handler
    <span class="dim">&#40;</span>ring/router
      &#91;&quot;/hello&quot;
       {:get
        {:handler
         <span class="dim">&#40;</span>fn &#91;&#95;&#93;
           {:headers {&quot;Content-Type&quot; &quot;text/html&quot;}
            :status  200
            :body    <span class="dim">&#40;</span>do
                       <span class="dim">;; simulate work by sleeping
</span>                       <span class="dim">;; for 50 milliseconds
</span>                       <span class="dim">&#40;</span>Thread/sleep 50<span class="dim">&#41;</span>
                       <span class="dim">&#40;</span>h/render &#91;:b &quot;hello!&quot;&#93;<span class="dim">&#41;&#41;</span>}<span class="dim">&#41;</span>}}&#93;
      ...<span class="dim">&#41;&#41;&#41;</span>
</code></pre><p>First we will create a http-kit server without virtual threads so that we can make a performance comparison.</p><pre><code class="Clojure"><span class="dim">&#40;</span>def <strong>server</strong> <span class="dim">&#40;</span>hk-server/run-server #'app
                {:port 8080
                 :thread 50}<span class="dim">&#41;&#41;</span>
</code></pre><p>Then benchmark it with <a href='https://github.com/wg/wrk'>wrk (a http server benchmarking tool)</a>.</p><pre><code>wrk -t 12 -c 120 http://127.0.0.1:8080/hello

Running 10s test @ http://127.0.0.1:8080/hello
12 threads and 120 connections
Requests/sec:    928.14
Transfer/sec:    134.15KB
</code></pre><p>Stop the http-kit server.</p><pre><code class="Clojure"><span class="dim">&#40;</span>server<span class="dim">&#41;</span>
</code></pre><p>Now, we will create a http-kit server that uses virtual threads.</p><pre><code class="Clojure"><span class="dim">&#40;</span>def <strong>server</strong> <span class="dim">&#40;</span>hk-server/run-server #'app
              {:port        8080
               :worker-pool <span class="dim">&#40;</span>Executors/newVirtualThreadPerTaskExecutor<span class="dim">&#41;</span>}<span class="dim">&#41;&#41;</span>
</code></pre><p>Then benchmark it.</p><pre><code>wrk -t 12 -c 120 http://127.0.0.1:8080/hello

Running 10s test @ http://127.0.0.1:8080/hello
12 threads and 120 connections
Requests/sec:   2208.67
Transfer/sec:    319.22KB
</code></pre><p>That's a 2.3x increase in performance. The increase is not due to virtual threads per say but due to virtual thread pools having an unlimited number of threads versus a fixed-size thread pool (50 threads). However, what this does highlight is that with virtual thread you no longer need to right size thread pools in environments with lots of IO, you get near-optimal utilisation without the need for manual and machine specific tuning.</p><p>The full example <a href='https://github.com/andersmurphy/clj-cookbook/tree/master/virtual-threads/http-kit'>project can be found here</a>.</p><p>For setting up <a href='https://andersmurphy.com/2023/09/16/clojure-virtual-threads-with-ring-and-jetty.html'>virtual threads with jetty checkout this post</a>.</p><p><strong>Update (2023-09-18):</strong> This post originally showed a 29x increase in performance when switching to virtual threads this was because http-kit was not configured correctly for operating with synchronous request handlers (the default is only 4 threads). <a href='https://www.reddit.com/r/Clojure/comments/16lq5gr/comment/k14ugqu/?utm_source=share&utm_medium=web2x&context=3'>As was kindly pointed out in this comment on reddit by the maintainer</a>. I have since updated the post to reflect benchmarks with a http-kit configured to use the same number of threads as Jetty's default (50 threads).</p></article><div class="footer"><p>Â© 2015-2024 Anders Murphy</p></div></div></body></html>