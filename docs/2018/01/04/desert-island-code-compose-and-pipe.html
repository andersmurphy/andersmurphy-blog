<p>You awake a castaway on a desert island. After some time you come across an ancient computation device, the programming of which might hold your salvation!</p><p>The device, though limitless in computational power, for better or worse only understands javascript. Alas this dialect of javascript doesn't have access to: compose and pipe!</p><p><!&ndash;more&ndash;></p><p>A cruel fate indeed.</p><p>But wait, what if we were to write our own implementations of: pipe and compose?</p><h3>Pipe</h3><p>What does pipe do?</p><p>Pipe allows left-to-right function composition. The leftmost function may have any arity; but the remaining functions must be unary.</p><p>The <code>pipe</code> function takes a variable number of functions <code>...fns</code> and returns a function that takes a single argument which we will call <code>seed</code>.</p><pre><code class="javascript">const pipe = &#40;...fns&#41; =&gt; seed =&gt; console.log&#40;'do stuff here'&#41;
</code></pre><p>Then, we reduce over the functions <code>...fns</code> passing the previous output <code>previousOutput</code> of each function into the next function until there are no more functions left.</p><pre><code class="javascript">const pipe = &#40;...fns&#41; =&gt; seed =&gt; fns.reduce&#40;
  &#40;previousOutput, fn&#41; =&gt; fn&#40;previousOutput&#41;,
  seed
&#41;

const map = mapFunc =&gt; coll =&gt; coll.map&#40;mapFunc&#41;

pipe&#40;map&#40;x =&gt; x - 2&#41;, map&#40;x =&gt; x &#42; 2&#41;&#41;&#40;&#91;1, 2, 3&#93;&#41; // &#91;-2,0,2&#93;
</code></pre><h3>Compose</h3><p>What does compose do?</p><p>Compose allows right-to-left function composition. The rightmost function may have any arity; but the remaining functions must be unary. Basically, the same as pipe just from right-to-left.</p><p>The <code>compose</code> function takes a variable number of functions and returns a function that takes a single argument which we will call <code>seed</code>.</p><pre><code class="javascript">const compose = &#40;...fns&#41; =&gt; seed =&gt; console.log&#40;'do stuff here'&#41;
{% endhighlight %}
</code></pre><p>Then, we reduce over the functions <code>...fns</code> passing the previous output <code>previousOutput</code> of each function into the next function until there are no more functions left.</p><pre><code class="javascript">const compose = &#40;...fns&#41; =&gt; seed =&gt; fns.reduceRight&#40;
  &#40;previousOutput, fn&#41; =&gt; fn&#40;previousOutput&#41;,
  seed
&#41;

const map = mapFunc =&gt; coll =&gt; coll.map&#40;mapFunc&#41;

compose&#40;map&#40;x =&gt; x - 2&#41;, map&#40;x =&gt; x &#42; 2&#41;&#41;&#40;&#91;1, 2, 3&#93;&#41; // &#91;0,2,4&#93;
</code></pre><h3>Bonus: Reduce Right</h3><p>We saw how to write our own implementation of reduce in <a href='https://andersmurphy.com/2017/12/28/desert-island-code-reduce-map-and-filter/'>this post</a>. But how would we implement reduce right? Reduce right is almost identical to reduce except it loops over the collection backwards.</p><p>Here's one way we could implement it:</p><pre><code class="javascript">const reduceRight = &#40;reduceFunc, startingValue, coll&#41; =&gt; {
  let accumulator = startingValue
  for&#40;let i = coll.length - 1; i &gt;= 0; i--&#41; {
    accumulator = reduceFunc&#40;accumulator, coll&#91;i&#93;&#41;
  }
  return accumulator
}

reduceRight&#40;&#40;acc, item&#41; =&gt; acc + item, 0, &#91; 1, 2, 3, 4&#93;&#41; // 10
</code></pre><p>So there you have it. Pipe, compose and reduce right on a desert island.</p>