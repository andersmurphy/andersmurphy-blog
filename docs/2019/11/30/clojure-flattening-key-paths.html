<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: flattening key paths</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos; &apos;unsafe-inline&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="/styles.css" rel="stylesheet" type="text/css" /><link href="/assets/favicon.png" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><nav class="container"><ul><li><div style="align-items:center;display:flex;"><img alt="portrait" height="40px" src="/assets/avatar.png" style="image-rendering:pixelated;padding:4px;" width="40px" /><h1 style="margin-bottom:0;"><a class="contrast" href="/">anders murphy</a></h1></div></li></ul><ul><li><a aria-label="Github" class="contrast no-chaos" href="https://github.com/andersmurphy"><svg class="icon-github" height="24" viewBox="0 0 496 512" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></li><li><a aria-label="Twitter" class="contrast no-chaos" href="https://twitter.com/anders_murphy"><svg class="icon-x" height="24" viewBox="0 0 512 512" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"></path></svg></a></li><li><a aria-label="LinkedIn" class="contrast no-chaos" href="https://uk.linkedin.com/in/anders-murphy-76457b3a"><svg class="linkedin" fill="currentColor" height="24" viewBox="0 0 16 16" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854zm4.943 12.248V6.169H2.542v7.225zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248S2.4 3.226 2.4 3.934c0 .694.521 1.248 1.327 1.248zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016l.016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225z"></path></svg></a></li><li><a aria-label="RSS" class="contrast no-chaos" href="/feed.xml"><svg class="bi bi-rss-fill" fill="currentColor" height="24" viewBox="0 0 16 16" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm1.5 2.5c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1 0-2m0 4a6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1 0-2m.5 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3"></path></svg></a></li></ul></nav><div class="container"><article><hgroup><h1>Clojure: flattening key paths</h1><p><time datetime="2019-11-30T00:00:00+00:00">30 Nov 2019</time></p></hgroup><hr /><p>This article will cover how to flatten the nested key paths of a map in Clojure; turning a nested map like <code>{:a {:b {:c {:d 1} :e 2}}}</code> into a flat map like <code>{:a-b-c-d 1 :a-b-e 2}</code>.</p><h2 id="flattening_key_paths_recursively">Flattening key paths recursively</h2><p>We <code>map</code> over the key value pairs of the top level map. If we encounter a <code>map?</code> that is <code>not-empty</code>, we <code>conj</code> the current key onto a vector, thus gradually building a path and then call <code>flatten-paths</code> recursively. If we encounter anything else, we take the current path and turn it into a single key:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>flatten-paths</strong>
  <span class="dim">&#40;</span>&#91;m separator&#93;
   <span class="dim">&#40;</span>flatten-paths m separator &#91;&#93;<span class="dim">&#41;&#41;</span>
  <span class="dim">&#40;</span>&#91;m separator path&#93;
   <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;&#91;k v&#93;&#93;
               <span class="dim">&#40;</span>if <span class="dim">&#40;</span>and <span class="dim">&#40;</span>map? v<span class="dim">&#41;</span> <span class="dim">&#40;</span>not-empty v<span class="dim">&#41;&#41;</span>
                 <span class="dim">&#40;</span>flatten-paths v separator <span class="dim">&#40;</span>conj path k<span class="dim">&#41;&#41;</span>
                 &#91;<span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>conj path k<span class="dim">&#41;</span>
                       <span class="dim">&#40;</span>map name<span class="dim">&#41;</span>
                       <span class="dim">&#40;</span>clojure.string/join separator<span class="dim">&#41;</span>
                       keyword<span class="dim">&#41;</span> v&#93;<span class="dim">&#41;&#41;</span>
             m<span class="dim">&#41;</span>
        <span class="dim">&#40;</span>into {}<span class="dim">&#41;&#41;&#41;&#41;</span>
</code></pre><p>This works for shallow maps:</p><pre><code class="clojure"><span class="dim">&#40;</span>flatten-paths {:a {:b {:c {:d 1}
                        :e 2}}
                :f 3}
                &quot;-&quot;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> {:a-b-c-d 1, :a-b-e 2, :f 3}
</code></pre><p>But does it work with deeply nested maps? To check this we first need to write a function <code>create-n-nested-map</code> that will create a deeply nested map:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>create-n-nested-map</strong> &#91;n&#93;
  <span class="dim">&#40;</span>assoc-in {} <span class="dim">&#40;</span>repeat n :a<span class="dim">&#41;</span> {}<span class="dim">&#41;&#41;</span>
</code></pre><p>And a harness <code>find-when-overflow-occurs</code> to tell us roughly at what depth we get a <code>StackOverflowError</code>:</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>find-when-overflow-occurs</strong> &#91;f n&#93;
  <span class="dim">&#40;</span>if <span class="dim">&#40;</span>try
        <span class="dim">&#40;</span>f n<span class="dim">&#41;</span>
        <span class="dim">&#40;</span>catch StackOverflowError e
          false<span class="dim">&#41;&#41;</span>
    <span class="dim">&#40;</span>recur f <span class="dim">&#40;</span>inc n<span class="dim">&#41;&#41;</span>
    n<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>find-when-overflow-occurs
          <span class="dim">&#40;</span>flatten-paths <span class="dim">&#40;</span>create-n-nested-map n<span class="dim">&#41;</span> &quot;-&quot;<span class="dim">&#41;</span>
          0<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> 599
</code></pre><p>On my machine I get a stack overflow at a depth of 600. In practice, you are unlikely to encounter a map that is this deeply nested. However, lets see if we can refactor <code>flatten-paths</code> to use the sequence abstraction so that it can handle deeper maps.</p><h2 id="flattening_key_paths_with_lazy-seq">Flattening key paths with lazy-seq</h2><p>The <code>lazy-seq</code> takes a body of expressions that returns an <code>ISeq</code> or <code>nil</code> and yields a <code>Seqable</code> object that will invoke the body only the first time <code>seq</code> is called. It will cache the result and return it on all subsequent seq calls. The caching of the body is what allows the <code>lazy-seq</code> macro to call itself recursively without consuming more stackframes the way a normal recursive call would.</p><p>We use <code>lazy-seq</code> to define a function that recursively builds a list of the flattened key paths. The use of <code>&#40;when-let &#91;&#91;x &amp; xs&#93; &#40;seq s&#41;&#93; ...&#41;</code> is a common pattern when building lazy sequences, allowing you to apply a function to the head of the sequence and then call it recursively on the tail. It's also worth noting that to combine the output of the head and the tail operations we use <code>into</code> (strict) rather than <code>concat</code> (lazy). For more details check out <a href='https://stuartsierra.com/2015/04/26/clojure-donts-concat'>this article</a>.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>flatten-paths</strong> &#91;m separator&#93;
    <span class="dim">&#40;</span>letfn &#91;<span class="dim">&#40;</span>flatten-paths &#91;m separator path&#93;
              <span class="dim">&#40;</span>lazy-seq
               <span class="dim">&#40;</span>when-let &#91;&#91;&#91;k v&#93; &amp; xs&#93; <span class="dim">&#40;</span>seq m<span class="dim">&#41;</span>&#93;
                 <span class="dim">&#40;</span>cond <span class="dim">&#40;</span>and <span class="dim">&#40;</span>map? v<span class="dim">&#41;</span> <span class="dim">&#40;</span>not-empty v<span class="dim">&#41;&#41;</span>
                       <span class="dim">&#40;</span>into <span class="dim">&#40;</span>flatten-paths v separator <span class="dim">&#40;</span>conj path k<span class="dim">&#41;&#41;</span>
                             <span class="dim">&#40;</span>flatten-paths xs separator path<span class="dim">&#41;&#41;</span>
                       :else
                       <span class="dim">&#40;</span>cons <strong>&#91;<span class="dim">&#40;</span>-&gt;&gt;</strong> <span class="dim">&#40;</span>conj path k<span class="dim">&#41;</span>
                                   <span class="dim">&#40;</span>map name<span class="dim">&#41;</span>
                                   <span class="dim">&#40;</span>clojure.string/join separator<span class="dim">&#41;</span>
                                   keyword<span class="dim">&#41;</span> v&#93;
                             <span class="dim">&#40;</span>flatten-paths xs separator path<span class="dim">&#41;&#41;&#41;&#41;&#41;&#41;</span>&#93;
      <span class="dim">&#40;</span>into {} <span class="dim">&#40;</span>flatten-paths m separator &#91;&#93;<span class="dim">&#41;&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>flatten-paths <span class="dim">&#40;</span>create-n-nested-map 1000000<span class="dim">&#41;</span> &quot;-&quot;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
Execution error <span class="dim">&#40;</span>StackOverflowError<span class="dim">&#41;</span> at user/flatten-paths<span class="dim">...</span>

</code></pre><p>But for some reason we are still getting a <code>StackOverflowError</code>. Maybe it's our <code>create-n-nested-map</code> function that's the culprit?</p><pre><code class="clojure"><span class="dim">&#40;</span>find-when-overflow-occurs
 create-n-nested-map
 0<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> 5889
</code></pre><p>Interesting... so <code>assoc-in</code> seems to be the cause. I guess this highlights just how unlikely you are to encounter such ridiculously nested maps. Let's rewrite <code>create-n-nested-map</code> to build the map from the inside out with <code>reduce</code> rather than outside in with <code>assoc-in</code>.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>create-n-nested-map</strong> &#91;n&#93;
  <span class="dim">&#40;</span>reduce <span class="dim">&#40;</span>fn &#91;acc &#95;&#93; {:a acc}<span class="dim">&#41;</span> {} <span class="dim">&#40;</span>range n<span class="dim">&#41;&#41;&#41;</span>
</code></pre><p>Let's see if that works. Warning! The output is quite large and will flood your repl.</p><pre><code class="clojure"><span class="dim">&#40;</span>flatten-paths <span class="dim">&#40;</span>create-n-nested-map 1000000<span class="dim">&#41;</span> &quot;-&quot;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> {:a-a-a-a-a-a<span class="dim">...</span> {}}
</code></pre><p>Rejoice! We can now flatten the key paths of ridiculously deeply nested maps.</p><p>This concludes this guide to flattening key paths in Clojure.</p></article><footer><p>© 2015-2024 Anders Murphy</p></footer></div></body></html>