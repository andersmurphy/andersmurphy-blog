<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: case conversion and boundaries</title><meta content="
base-uri    &apos;self&apos;;
form-action &apos;self&apos;;
default-src &apos;none&apos;;
script-src  &apos;self&apos;;
img-src     &apos;self&apos;;
font-src    &apos;self&apos;;
connect-src &apos;self&apos;;
style-src   &apos;self&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="/styles.css" rel="stylesheet" type="text/css" /><link href="/assets/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144" /><link href="/assets/favicon.ico" rel="shortcut icon" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="A blog mostly about software development." name="description" /></head><body><div class="sidebar"><div class="container sidebar-sticky"><div class="sidebar-about"><img alt="portrait" class="portrait" height="120" src="/assets/anderspixel.png" width="60" /><h1><a href="/">Anders Murphy</a></h1><p class="lead">A blog mostly about functional programming</p></div><nav class="sidebar-nav"><a class="sidebar-nav-item" href="https://github.com/andersmurphy">Github</a><a class="sidebar-nav-item" href="https://twitter.com/anders_murphy">Twitter</a><a class="sidebar-nav-item" href="https://uk.linkedin.com/in/anders-murphy-76457b3a">LinkedIn</a><a class="sidebar-nav-item" href="/feed.xml">RSS</a></nav></div></div><div class="content container"><article class="post"><h1 class="post-title">Clojure: case conversion and boundaries</h1><time class="post-date" datetime="2019-05-04T00:00:00+00:00">04 May 2019</time><p>Inconsistent case is a problems that tends to come up at application boundaries in your software stack. For example your Clojure codebase might use <code>kebab-case</code> for keywords, whilst your database uses <code>snake&#95;case</code> for column names and your client wants <code>camelCase</code> in its json responses. Often, conventions and/or technical limitations prevent you from simply having a single case throughout your entire stack.</p><p>One "solution" to this problem is to accept the fact that your app will have a mix of cases. However, this can lead to mistake and frustration, does this function expect <code>customer-id</code>, <code>cutomerId</code> or <code>customer&#95;id</code>? What format does our mobile client expect? A more practical solution to this problem, the one this article will cover, is to add automatic case conversion at these boundaries in your software stack.</p><h2 id="converting_the_case_of_a_key">Converting the case of a key</h2><p>Let's start by writing a simple case conversion function for converting <code>kebab-case</code> keywords to <code>camelCase</code> keywords.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>kebab-case-&gt;camelCase</strong> &#91;k&#93;
  <span class="dim">&#40;</span>let &#91;words <span class="dim">&#40;</span>clojure.string/split <span class="dim">&#40;</span>name k<span class="dim">&#41;</span> #&quot;-&quot;<span class="dim">&#41;</span>&#93;
    <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>map clojure.string/capitalize <span class="dim">&#40;</span>rest words<span class="dim">&#41;&#41;</span>
         <span class="dim">&#40;</span>apply str <span class="dim">&#40;</span>first words<span class="dim">&#41;&#41;</span>
         keyword<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>kebab-case-&gt;camelCase :foo-bar-baz<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> :fooBarBaz
</code></pre><h2 id="converting_the_case_of_keys_in_a_map">Converting the case of keys in a map</h2><p>Now that we have a function for converting case let's convert all the keys of a map using the <code>map-keys</code> function we implemented in <a href='https://andersmurphy.com/2018/11/10/clojure-map-values-and-keys.html'>this article</a>.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>map-keys</strong> &#91;f m&#93;
  <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;&#91;k v&#93;&#93; &#91;<span class="dim">&#40;</span>f k<span class="dim">&#41;</span> v&#93;<span class="dim">&#41;</span> m<span class="dim">&#41;</span>
       <span class="dim">&#40;</span>into {}<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>map-keys kebab-case-&gt;camelCase
          {:character-id 1 :first-name &quot;John&quot; :second-name &quot;Snow&quot;}<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> {:characterId 1, :firstName &quot;John&quot;, :secondName &quot;Snow&quot;}
</code></pre><p><strong>UPDATE:</strong> <em>As of Clojure 1.11.0 there is now a built in function in <code>clojure.core</code> called <code>update-keys</code> which behaves identically to <code>map-keys</code> but takes the arguments in the opposite order <code>&#40;update-keys m f&#41;</code>.</em></p><h2 id="converting_case_of_keys_in_a_nested_data_structure">Converting case of keys in a nested data structure</h2><p>For converting the keys of arbitrarily nested data structures we can use the <code>clojure.walk/postwalk</code> function. Let's check out the docs.</p><pre><code class="clojure"><span class="dim">&#40;</span>doc clojure.walk/postwalk<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
-------------------------
clojure.walk/postwalk
<span class="dim">&#40;</span>&#91;f form&#93;<span class="dim">&#41;</span>
  Performs a depth-first, post-order traversal of form.  Calls f on
  each sub-form, uses f's return value in place of the original.
  Recognizes all Clojure data structures. Consumes seqs as with doall.
</code></pre><p>Combining <code>clojure.walk/postwalk</code> with our <code>map-keys</code> function we can create a <code>transform-keys</code> function that will take a transformation function and apply it to all keys in a data structure.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>transform-keys</strong> &#91;t form&#93;
  <span class="dim">&#40;</span>clojure.walk/postwalk <span class="dim">&#40;</span>fn &#91;x&#93; <span class="dim">&#40;</span>if <span class="dim">&#40;</span>map? x<span class="dim">&#41;</span> <span class="dim">&#40;</span>map-keys t x<span class="dim">&#41;</span> x<span class="dim">&#41;&#41;</span> form<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>transform-keys kebab-case-&gt;camelCase
 &#91;{:character-id 1
   :first-name &quot;Olaf&quot;
   :second-name &quot;Iondrake&quot;
   :items {:bag-of-holding &#91;&quot;sword&quot; &quot;axe&quot; &quot;money&quot;&#93;}}
  {:character-Id 2
   :first-name &quot;Sigurd&quot;
   :second-name &quot;Rockfist&quot;
   :items {:bag-of-holding &#91;&quot;scroll&quot; &quot;potion of healing&quot;&#93;}}&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> &#91;{:characterId 1,
     :firstName &quot;Olaf&quot;,
     :secondName &quot;Irondrake&quot;,
     :items {:bagOfHolding &#91;&quot;sword&quot; &quot;axe&quot; &quot;money&quot;&#93;}}
    {:characterId 2,
     :firstName &quot;Sigurd&quot;,
     :secondName &quot;Rockfist&quot;,
     :items {:bagOfHolding &#91;&quot;scroll&quot; &quot;potion of healing&quot;&#93;}}&#93;
</code></pre><p>There you have it, a function for converting the case of keys in an arbitrarily nested data structure. You can use this function at the boundaries of your software stack to keep you and your team sane.</p><p>For more robust case conversion checkout the awesome <a href='https://github.com/clj-commons/camel-snake-kebab'>camel-snake-kebab</a> library.</p></article><div class="footer"><p>Â© 2015-2024 Anders Murphy</p></div></div></body></html>