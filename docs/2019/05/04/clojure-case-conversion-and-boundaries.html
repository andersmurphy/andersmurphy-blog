<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8" /><title>Clojure: case conversion and boundaries</title><meta content="
base-uri        &apos;self&apos;;
form-action     &apos;self&apos;;
default-src     &apos;none&apos;;
script-src      &apos;self&apos;;
img-src         &apos;self&apos;;
font-src        &apos;self&apos;;
connect-src     &apos;self&apos;;
frame-src       https://example.andersmurphy.com;
style-src       &apos;self&apos; &apos;unsafe-inline&apos;
" http-equiv="Content-Security-Policy" /><meta content="text/html; charset=UTF-8" http-equiv="content-type" /><link href="/styles.css" rel="stylesheet" type="text/css" /><link href="/assets/favicon.png" rel="shortcut icon" /><script defer="defer" src="/toggle.js"></script><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="same-origin" name="view-transition" /><meta content="A blog mostly about Clojure programming" name="description" /></head><body><header class="nav-sticky-top container-fluid"><nav class="container"><ul><li><div class="linkify" style="align-items:center;display:flex;"><img alt="portrait" height="40px" src="/assets/avatar.png" style="image-rendering:pixelated;padding:4px;" width="40px" /><h1 style="margin-bottom:0;">anders murphy</h1><a aria-label="Home" href="/"></a></div></li></ul><ul><li><a aria-label="Github" class="contrast no-chaos" href="https://github.com/andersmurphy"><svg class="icon" height="24" style="margin-bottom:6px;margin-top:6px;" viewBox="0 0 496 512" width="24" xmlns="http://www.w3.org/2000/svg"><linearGradient id="gradient-horizontal"><stop offset="0%" stop-color="var(--color-stop-1)"></stop><stop offset="33%" stop-color="var(--color-stop-2)"></stop><stop offset="66%" stop-color="var(--color-stop-3)"></stop><stop offset="100%" stop-color="var(--color-stop-4)"></stop></linearGradient><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></li><li><a aria-label="RSS" class="contrast no-chaos" href="/feed.xml"><svg class="icon" height="24" style="margin-bottom:6px;margin-top:6px;" viewBox="0 0 16 16" width="24" xmlns="http://www.w3.org/2000/svg"><linearGradient id="gradient-horizontal"><stop offset="0%" stop-color="var(--color-stop-1)"></stop><stop offset="33%" stop-color="var(--color-stop-2)"></stop><stop offset="66%" stop-color="var(--color-stop-3)"></stop><stop offset="100%" stop-color="var(--color-stop-4)"></stop></linearGradient><path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm1.5 2.5c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1 0-2m0 4a6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1 0-2m.5 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3"></path></svg></a></li><li><div class="theme-toggle" id="toggle"><svg aria-hidden="true" class="icon theme-toggle__inner-moon" height="30" viewBox="0 0 32 32" width="30" xmlns="http://www.w3.org/2000/svg"><path d="M27.5 11.5v-7h-7L16 0l-4.5 4.5h-7v7L0 16l4.5 4.5v7h7L16 32l4.5-4.5h7v-7L32 16l-4.5-4.5zM16 25.4a9.39 9.39 0 1 1 0-18.8 9.39 9.39 0 1 1 0 18.8z"></path><circle cx="16" cy="16" r="8.1"></circle></svg></div></li></ul></nav></header><main class="container"><article><hgroup><h1>Clojure: case conversion and boundaries</h1><p><time datetime="2019-05-04T00:00:00+00:00">04 May 2019</time></p></hgroup><hr /><p>Inconsistent case is a problems that tends to come up at application boundaries in your software stack. For example your Clojure codebase might use <code>kebab-case</code> for keywords, whilst your database uses <code>snake&#95;case</code> for column names and your client wants <code>camelCase</code> in its json responses. Often, conventions and/or technical limitations prevent you from simply having a single case throughout your entire stack.</p><p>One "solution" to this problem is to accept the fact that your app will have a mix of cases. However, this can lead to mistake and frustration, does this function expect <code>customer-id</code>, <code>cutomerId</code> or <code>customer&#95;id</code>? What format does our mobile client expect? A more practical solution to this problem, the one this article will cover, is to add automatic case conversion at these boundaries in your software stack.</p><h2 id="converting_the_case_of_a_key">Converting the case of a key</h2><p>Let's start by writing a simple case conversion function for converting <code>kebab-case</code> keywords to <code>camelCase</code> keywords.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>kebab-case-&gt;camelCase</strong> &#91;k&#93;
  <span class="dim">&#40;</span>let &#91;words <span class="dim">&#40;</span>clojure.string/split <span class="dim">&#40;</span>name k<span class="dim">&#41;</span> #&quot;-&quot;<span class="dim">&#41;</span>&#93;
    <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>map clojure.string/capitalize <span class="dim">&#40;</span>rest words<span class="dim">&#41;&#41;</span>
         <span class="dim">&#40;</span>apply str <span class="dim">&#40;</span>first words<span class="dim">&#41;&#41;</span>
         keyword<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>kebab-case-&gt;camelCase :foo-bar-baz<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> :fooBarBaz
</code></pre><h2 id="converting_the_case_of_keys_in_a_map">Converting the case of keys in a map</h2><p>Now that we have a function for converting case let's convert all the keys of a map using the <code>map-keys</code> function we implemented in <a href='https://andersmurphy.com/2018/11/10/clojure-map-values-and-keys.html'>this article</a>.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>map-keys</strong> &#91;f m&#93;
  <span class="dim">&#40;</span>-&gt;&gt; <span class="dim">&#40;</span>map <span class="dim">&#40;</span>fn &#91;&#91;k v&#93;&#93; &#91;<span class="dim">&#40;</span>f k<span class="dim">&#41;</span> v&#93;<span class="dim">&#41;</span> m<span class="dim">&#41;</span>
       <span class="dim">&#40;</span>into {}<span class="dim">&#41;&#41;&#41;</span>

<span class="dim">&#40;</span>map-keys kebab-case-&gt;camelCase
          {:character-id 1 :first-name &quot;John&quot; :second-name &quot;Snow&quot;}<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> {:characterId 1, :firstName &quot;John&quot;, :secondName &quot;Snow&quot;}
</code></pre><p><strong>UPDATE:</strong> <em>As of Clojure 1.11.0 there is now a built in function in <code>clojure.core</code> called <code>update-keys</code> which behaves identically to <code>map-keys</code> but takes the arguments in the opposite order <code>&#40;update-keys m f&#41;</code>.</em></p><h2 id="converting_case_of_keys_in_a_nested_data_structure">Converting case of keys in a nested data structure</h2><p>For converting the keys of arbitrarily nested data structures we can use the <code>clojure.walk/postwalk</code> function. Let's check out the docs.</p><pre><code class="clojure"><span class="dim">&#40;</span>doc clojure.walk/postwalk<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span>
-------------------------
clojure.walk/postwalk
<span class="dim">&#40;</span>&#91;f form&#93;<span class="dim">&#41;</span>
  Performs a depth-first, post-order traversal of form.  Calls f on
  each sub-form, uses f's return value in place of the original.
  Recognizes all Clojure data structures. Consumes seqs as with doall.
</code></pre><p>Combining <code>clojure.walk/postwalk</code> with our <code>map-keys</code> function we can create a <code>transform-keys</code> function that will take a transformation function and apply it to all keys in a data structure.</p><pre><code class="clojure"><span class="dim">&#40;</span>defn <strong>transform-keys</strong> &#91;t form&#93;
  <span class="dim">&#40;</span>clojure.walk/postwalk <span class="dim">&#40;</span>fn &#91;x&#93; <span class="dim">&#40;</span>if <span class="dim">&#40;</span>map? x<span class="dim">&#41;</span> <span class="dim">&#40;</span>map-keys t x<span class="dim">&#41;</span> x<span class="dim">&#41;&#41;</span> form<span class="dim">&#41;&#41;</span>

<span class="dim">&#40;</span>transform-keys kebab-case-&gt;camelCase
 &#91;{:character-id 1
   :first-name &quot;Olaf&quot;
   :second-name &quot;Iondrake&quot;
   :items {:bag-of-holding &#91;&quot;sword&quot; &quot;axe&quot; &quot;money&quot;&#93;}}
  {:character-Id 2
   :first-name &quot;Sigurd&quot;
   :second-name &quot;Rockfist&quot;
   :items {:bag-of-holding &#91;&quot;scroll&quot; &quot;potion of healing&quot;&#93;}}&#93;<span class="dim">&#41;</span>
<span class="dim">
=&gt;</span> &#91;{:characterId 1,
     :firstName &quot;Olaf&quot;,
     :secondName &quot;Irondrake&quot;,
     :items {:bagOfHolding &#91;&quot;sword&quot; &quot;axe&quot; &quot;money&quot;&#93;}}
    {:characterId 2,
     :firstName &quot;Sigurd&quot;,
     :secondName &quot;Rockfist&quot;,
     :items {:bagOfHolding &#91;&quot;scroll&quot; &quot;potion of healing&quot;&#93;}}&#93;
</code></pre><p>There you have it, a function for converting the case of keys in an arbitrarily nested data structure. You can use this function at the boundaries of your software stack to keep you and your team sane.</p><p>For more robust case conversion checkout the awesome <a href='https://github.com/clj-commons/camel-snake-kebab'>camel-snake-kebab</a> library.</p></article><footer><p>© 2015-2025 Anders Murphy</p></footer></main></body></html>